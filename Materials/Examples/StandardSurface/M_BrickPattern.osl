#include "mx_funcs.h"

#define true 1
#define false 0
struct textureresource { string filename; string colorspace; };
#define BSDF closure color
#define EDF closure color
#define VDF closure color
struct surfaceshader { closure color bsdf; closure color edf; float opacity; };
#define volumeshader closure color
#define displacementshader vector
#define lightshader closure color
#define MATERIAL closure color

#define M_FLOAT_EPS 1e-8

void NG_convert_float_vector2(float in, output vector2 out)
{
    vector2 combine_out = { in,in };
    out = combine_out;
}

void mx_rgbtohsv_color3(vector _in, output vector result)
{
    result = transformc("rgb","hsv", _in);
}

vector2 mx_transform_uv(vector2 texcoord)
{
    return texcoord;
}

void mx_image_float(textureresource file, string layer, float default_value, vector2 texcoord, string uaddressmode, string vaddressmode, string filtertype, string framerange, int frameoffset, string frameendaction, output float out)
{
    if (file.filename == "" ||
        (uaddressmode == "constant" && (texcoord.x<0.0 || texcoord.x>1.0)) ||
        (vaddressmode == "constant" && (texcoord.y<0.0 || texcoord.y>1.0)))
    {
        out = default_value;
        return;
    }

    color missingColor = color(default_value);
    vector2 st = mx_transform_uv(texcoord);
    color rgb = texture(file.filename, st.x, st.y, "subimage", layer, "missingcolor", missingColor, "swrap", uaddressmode, "twrap", vaddressmode);
    out = rgb[0];
}

void NG_tiledimage_float(textureresource  file, float default1, vector2 texcoord, vector2 uvtiling, vector2 uvoffset, vector2 realworldimagesize, vector2 realworldtilesize, string filtertype, string framerange, int frameoffset, string frameendaction, output float out)
{
    vector2 N_mult_float_out = texcoord * uvtiling;
    vector2 N_sub_float_out = N_mult_float_out - uvoffset;
    vector2 N_divtilesize_float_out = N_sub_float_out / realworldimagesize;
    vector2 N_multtilesize_float_out = N_divtilesize_float_out * realworldtilesize;
    float N_img_float_out = 0.0;
    mx_image_float(file, "", default1, N_multtilesize_float_out, "periodic", "periodic", filtertype, framerange, frameoffset, frameendaction, N_img_float_out);
    out = N_img_float_out;
}


void mx_image_vector3(textureresource file, string layer, vector default_value, vector2 texcoord, string uaddressmode, string vaddressmode, string filtertype, string framerange, int frameoffset, string frameendaction, output vector out)
{
    if (file.filename == "" ||
        (uaddressmode == "constant" && (texcoord.x<0.0 || texcoord.x>1.0)) ||
        (vaddressmode == "constant" && (texcoord.y<0.0 || texcoord.y>1.0)))
    {
        out = default_value;
        return;
    }

    color missingColor = default_value;
    vector2 st = mx_transform_uv(texcoord);
    out = texture(file.filename, st.x, st.y, "subimage", layer, "missingcolor", missingColor, "swrap", uaddressmode, "twrap", vaddressmode);
}

void NG_tiledimage_vector3(textureresource  file, vector default1, vector2 texcoord, vector2 uvtiling, vector2 uvoffset, vector2 realworldimagesize, vector2 realworldtilesize, string filtertype, string framerange, int frameoffset, string frameendaction, output vector out)
{
    vector2 N_mult_vector3_out = texcoord * uvtiling;
    vector2 N_sub_vector3_out = N_mult_vector3_out - uvoffset;
    vector2 N_divtilesize_vector3_out = N_sub_vector3_out / realworldimagesize;
    vector2 N_multtilesize_vector3_out = N_divtilesize_vector3_out * realworldtilesize;
    vector N_img_vector3_out = vector(0.0);
    mx_image_vector3(file, "", default1, N_multtilesize_vector3_out, "periodic", "periodic", filtertype, framerange, frameoffset, frameendaction, N_img_vector3_out);
    out = N_img_vector3_out;
}

void mx_normalmap_vector2(vector value, vector2 normal_scale, vector N, vector T, vector B, output vector result)
{
    vector decodedValue;
    if (value == vector(0.0))
    {
        decodedValue = vector(0.0, 0.0, 1.0);
    }
    else
    {
        decodedValue = value * 2.0 - 1.0;
    }

    result = normalize(T * decodedValue[0] * normal_scale.x + B * decodedValue[1] * normal_scale.y + N * decodedValue[2]);
}

void mx_normalmap_float(vector value, float normal_scale, vector N, vector T, vector B, output vector result)
{
    mx_normalmap_vector2(value, vector2(normal_scale, normal_scale), N, T, B, result);
}

void mx_hsvtorgb_color3(vector _in, output vector result)
{
    result = transformc("hsv","rgb", _in);
}

void mx_roughness_anisotropy(float roughness, float anisotropy, output vector2 result)
{
    float roughness_sqr = clamp(roughness*roughness, M_FLOAT_EPS, 1.0);
    if (anisotropy > 0.0)
    {
        float aspect = sqrt(1.0 - clamp(anisotropy, 0.0, 0.98));
        result.x = min(roughness_sqr / aspect, 1.0);
        result.y = roughness_sqr * aspect;
    }
    else
    {
        result.x = roughness_sqr;
        result.y = roughness_sqr;
    }
}

void mx_luminance_color3(color in, color lumacoeffs, output color result)
{
    result = dot(in, lumacoeffs);
}

matrix rotationMatrix(vector axis, float angle)
{
    vector nAxis = normalize(axis);
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1.0 - c;

    return matrix(oc * nAxis[0] * nAxis[0] + c,             oc * nAxis[0] * nAxis[1] - nAxis[2] * s,  oc * nAxis[2] * nAxis[0] + nAxis[1] * s,  0.0,
                  oc * nAxis[0] * nAxis[1] + nAxis[2] * s,  oc * nAxis[1] * nAxis[1] + c,             oc * nAxis[1] * nAxis[2] - nAxis[0] * s,  0.0,
                  oc * nAxis[2] * nAxis[0] - nAxis[1] * s,  oc * nAxis[1] * nAxis[2] + nAxis[0] * s,  oc * nAxis[2] * nAxis[2] + c,             0.0,
                  0.0,                                      0.0,                                      0.0,                                      1.0);
}

void mx_rotate_vector3(vector _in, float amount, vector axis, output vector result)
{
    float rotationRadians = radians(amount);
    matrix m = rotationMatrix(axis, rotationRadians);
    vector4 trans = transform(m, vector4(_in[0], _in[1], _in[2], 1.0));
    result = vector(trans.x, trans.y, trans.z);
}

void mx_artistic_ior(color reflectivity, color edge_color, output vector ior, output vector extinction)
{
    // "Artist Friendly Metallic Fresnel", Ole Gulbrandsen, 2014
    // http://jcgt.org/published/0003/04/03/paper.pdf

    color r = clamp(reflectivity, 0.0, 0.99);
    color r_sqrt = sqrt(r);
    color n_min = (1.0 - r) / (1.0 + r);
    color n_max = (1.0 + r_sqrt) / (1.0 - r_sqrt);
    ior = mix(n_max, n_min, edge_color);

    color np1 = ior + 1.0;
    color nm1 = ior - 1.0;
    color k2 = (np1*np1 * r - nm1*nm1) / (1.0 - r);
    k2 = max(k2, 0.0);
    extinction = sqrt(k2);
}

void mx_dielectric_bsdf(float weight, color tint, float ior, vector2 roughness, float thinfilm_thickness, float thinfilm_ior, normal N, vector U, string distribution, string scatter_mode, output BSDF bsdf)
{
    if (scatter_mode == "R")
    {
        bsdf = weight * dielectric_bsdf(N, U, tint, color(0.0), roughness.x, roughness.y, ior, distribution, "thinfilm_thickness", thinfilm_thickness, "thinfilm_ior", thinfilm_ior);
    }
    else if (scatter_mode == "T")
    {
        bsdf = weight * dielectric_bsdf(N, U, color(0.0), tint, roughness.x, roughness.y, ior, distribution, "thinfilm_thickness", thinfilm_thickness, "thinfilm_ior", thinfilm_ior);
    }
    else
    {
        bsdf = weight * dielectric_bsdf(N, U, tint, tint, roughness.x, roughness.y, ior, distribution, "thinfilm_thickness", thinfilm_thickness, "thinfilm_ior", thinfilm_ior);
    }
}

void mx_subsurface_bsdf(float weight, color _color, color radius, float anisotropy, normal N, output BSDF bsdf)
{
    // TODO: Subsurface closure is not supported by vanilla OSL.
    bsdf = _color * weight * diffuse(N);
}

void NG_convert_float_color3(float in, output color out)
{
    color combine_out = color( in,in,in );
    out = combine_out;
}

float mx_square(float x)
{
    return x*x;
}

vector2 mx_square(vector2 x)
{
    return x*x;
}

vector mx_square(vector x)
{
    return x*x;
}

vector4 mx_square(vector4 x)
{
    return x*x;
}

float mx_pow5(float x)
{
    return mx_square(mx_square(x)) * x;
}

color mx_fresnel_conductor(float cosTheta, vector n, vector k)
{
   float c2 = cosTheta*cosTheta;
   vector n2_k2 = n*n + k*k;
   vector nc2 = 2.0 * n * cosTheta;

   vector rs_a = n2_k2 + c2;
   vector rp_a = n2_k2 * c2 + 1.0;
   vector rs = (rs_a - nc2) / (rs_a + nc2);
   vector rp = (rp_a - nc2) / (rp_a + nc2);

   return 0.5 * (rs + rp);
}

// Standard Schlick Fresnel
float mx_fresnel_schlick(float cosTheta, float F0)
{
    float x = clamp(1.0 - cosTheta, 0.0, 1.0);
    float x5 = mx_pow5(x);
    return F0 + (1.0 - F0) * x5;
}
color mx_fresnel_schlick(float cosTheta, color F0)
{
    float x = clamp(1.0 - cosTheta, 0.0, 1.0);
    float x5 = mx_pow5(x);
    return F0 + (1.0 - F0) * x5;
}

// Generalized Schlick Fresnel
float mx_fresnel_schlick(float cosTheta, float F0, float F90)
{
    float x = clamp(1.0 - cosTheta, 0.0, 1.0);
    float x5 = mx_pow5(x);
    return mix(F0, F90, x5);
}
color mx_fresnel_schlick(float cosTheta, color F0, color F90)
{
    float x = clamp(1.0 - cosTheta, 0.0, 1.0);
    float x5 = mx_pow5(x);
    return mix(F0, F90, x5);
}

// Generalized Schlick Fresnel with a variable exponent
color mx_fresnel_schlick(float cosTheta, float f0, float f90, float exponent)
{
    float x = clamp(1.0 - cosTheta, 0.0, 1.0);
    return mix(f0, f90, pow(x, exponent));
}
color mx_fresnel_schlick(float cosTheta, color f0, color f90, float exponent)
{
    float x = clamp(1.0 - cosTheta, 0.0, 1.0);
    return mix(f0, f90, pow(x, exponent));
}

void mx_generalized_schlick_edf(color color0, color color90, float exponent, EDF base, output EDF result)
{
    float NdotV = fabs(dot(N,-I));
    color f = mx_fresnel_schlick(NdotV, color0, color90, exponent);
    result = base * f;
}

void mx_surface(BSDF bsdf, EDF edf, float opacity, int thin_walled, output surfaceshader result)
{
    result.bsdf    = bsdf;
    result.edf     = edf;
    result.opacity = clamp(opacity, 0.0, 1.0);
}

void NG_standard_surface_surfaceshader_100(float base, color base_color, float diffuse_roughness, float metalness, float specular, color specular_color, float specular_roughness, float specular_IOR, float specular_anisotropy, float specular_rotation, float transmission, color transmission_color, float transmission_depth, color transmission_scatter, float transmission_scatter_anisotropy, float transmission_dispersion, float transmission_extra_roughness, float subsurface1, color subsurface_color, color subsurface_radius, float subsurface_scale, float subsurface_anisotropy, float sheen1, color sheen_color, float sheen_roughness, float coat, color coat_color, float coat_roughness, float coat_anisotropy, float coat_rotation, float coat_IOR, vector coat_normal, float coat_affect_color, float coat_affect_roughness, float thin_film_thickness, float thin_film_IOR, float emission1, color emission_color, color opacity, int thin_walled, vector normal1, vector tangent, output surfaceshader out)
{
    closure color null_closure = 0;
    vector2 coat_roughness_vector_out = vector2(0.0, 0.0);
    mx_roughness_anisotropy(coat_roughness, coat_anisotropy, coat_roughness_vector_out);
    float coat_tangent_rotate_degree_in2_tmp = 360.000000;
    float coat_tangent_rotate_degree_out = coat_rotation * coat_tangent_rotate_degree_in2_tmp;
    color metal_reflectivity_out = base_color * base;
    color metal_edgecolor_out = specular_color * specular;
    float coat_affect_roughness_multiply1_out = coat_affect_roughness * coat;
    float tangent_rotate_degree_in2_tmp = 360.000000;
    float tangent_rotate_degree_out = specular_rotation * tangent_rotate_degree_in2_tmp;
    float transmission_roughness_add_out = specular_roughness + transmission_extra_roughness;
    float subsurface_color_nonnegative_in2_tmp = 0.000000;
    color subsurface_color_nonnegative_out = max(subsurface_color, subsurface_color_nonnegative_in2_tmp);
    float coat_clamped_low_tmp = 0.000000;
    float coat_clamped_high_tmp = 1.000000;
    float coat_clamped_out = clamp(coat, coat_clamped_low_tmp, coat_clamped_high_tmp);
    color subsurface_radius_scaled_out = subsurface_radius * subsurface_scale;
    float subsurface_selector_out = float(thin_walled);
    float base_color_nonnegative_in2_tmp = 0.000000;
    color base_color_nonnegative_out = max(base_color, base_color_nonnegative_in2_tmp);
    color coat_attenuation_bg_tmp = color(1.000000, 1.000000, 1.000000);
    color coat_attenuation_out = mix(coat_attenuation_bg_tmp, coat_color, coat);
    float one_minus_coat_ior_in1_tmp = 1.000000;
    float one_minus_coat_ior_out = one_minus_coat_ior_in1_tmp - coat_IOR;
    float one_plus_coat_ior_in1_tmp = 1.000000;
    float one_plus_coat_ior_out = one_plus_coat_ior_in1_tmp + coat_IOR;
    color emission_weight_out = emission_color * emission1;
    color opacity_luminance_out = color(0.0);
    mx_luminance_color3(opacity, color(0.272229, 0.674082, 0.053689), opacity_luminance_out);
    vector coat_tangent_rotate_out = vector(0.0);
    mx_rotate_vector3(tangent, coat_tangent_rotate_degree_out, coat_normal, coat_tangent_rotate_out);
    color artistic_ior_ior = color(0.0);
    color artistic_ior_extinction = color(0.0);
    mx_artistic_ior(metal_reflectivity_out, metal_edgecolor_out, artistic_ior_ior, artistic_ior_extinction);
    float coat_affect_roughness_multiply2_out = coat_affect_roughness_multiply1_out * coat_roughness;
    vector tangent_rotate_out = vector(0.0);
    mx_rotate_vector3(tangent, tangent_rotate_degree_out, normal1, tangent_rotate_out);
    float transmission_roughness_clamped_low_tmp = 0.000000;
    float transmission_roughness_clamped_high_tmp = 1.000000;
    float transmission_roughness_clamped_out = clamp(transmission_roughness_add_out, transmission_roughness_clamped_low_tmp, transmission_roughness_clamped_high_tmp);
    float coat_gamma_multiply_out = coat_clamped_out * coat_affect_color;
    float coat_ior_to_F0_sqrt_out = one_minus_coat_ior_out / one_plus_coat_ior_out;
    int opacity_luminance_float_index_tmp = 0;
    float opacity_luminance_float_out = mx_extract(opacity_luminance_out, opacity_luminance_float_index_tmp);
    vector coat_tangent_rotate_normalize_out = normalize(coat_tangent_rotate_out);
    float coat_affected_roughness_fg_tmp = 1.000000;
    float coat_affected_roughness_out = mix(specular_roughness, coat_affected_roughness_fg_tmp, coat_affect_roughness_multiply2_out);
    vector tangent_rotate_normalize_out = normalize(tangent_rotate_out);
    float coat_affected_transmission_roughness_fg_tmp = 1.000000;
    float coat_affected_transmission_roughness_out = mix(transmission_roughness_clamped_out, coat_affected_transmission_roughness_fg_tmp, coat_affect_roughness_multiply2_out);
    float coat_gamma_in2_tmp = 1.000000;
    float coat_gamma_out = coat_gamma_multiply_out + coat_gamma_in2_tmp;
    float coat_ior_to_F0_out = coat_ior_to_F0_sqrt_out * coat_ior_to_F0_sqrt_out;
    float coat_tangent_value2_tmp = 0.000000;
    vector coat_tangent_out = mx_ternary(coat_anisotropy > coat_tangent_value2_tmp, coat_tangent_rotate_normalize_out, tangent);
    vector2 main_roughness_out = vector2(0.0, 0.0);
    mx_roughness_anisotropy(coat_affected_roughness_out, specular_anisotropy, main_roughness_out);
    float main_tangent_value2_tmp = 0.000000;
    vector main_tangent_out = mx_ternary(specular_anisotropy > main_tangent_value2_tmp, tangent_rotate_normalize_out, tangent);
    vector2 transmission_roughness_out = vector2(0.0, 0.0);
    mx_roughness_anisotropy(coat_affected_transmission_roughness_out, specular_anisotropy, transmission_roughness_out);
    color coat_affected_subsurface_color_out = pow(subsurface_color_nonnegative_out, coat_gamma_out);
    color coat_affected_diffuse_color_out = pow(base_color_nonnegative_out, coat_gamma_out);
    float one_minus_coat_ior_to_F0_in1_tmp = 1.000000;
    float one_minus_coat_ior_to_F0_out = one_minus_coat_ior_to_F0_in1_tmp - coat_ior_to_F0_out;
    color emission_color0_out = color(0.0);
    NG_convert_float_color3(one_minus_coat_ior_to_F0_out, emission_color0_out);
    BSDF coat_bsdf_out = null_closure;
    mx_dielectric_bsdf(coat, color(1.000000, 1.000000, 1.000000), coat_IOR, coat_roughness_vector_out, 0.000000, 1.500000, coat_normal, coat_tangent_out, "ggx", "R", coat_bsdf_out);
    float metal_bsdf_weight_tmp = 1.000000;
    string metal_bsdf_distribution_tmp = "ggx";
    BSDF metal_bsdf_out = metal_bsdf_weight_tmp * conductor_bsdf(normal1, main_tangent_out, main_roughness_out.x, main_roughness_out.y, artistic_ior_ior, artistic_ior_extinction, metal_bsdf_distribution_tmp, "thinfilm_thickness", thin_film_thickness, "thinfilm_ior", thin_film_IOR);
    BSDF specular_bsdf_out = null_closure;
    mx_dielectric_bsdf(specular, specular_color, specular_IOR, main_roughness_out, thin_film_thickness, thin_film_IOR, normal1, main_tangent_out, "ggx", "R", specular_bsdf_out);
    BSDF transmission_bsdf_out = null_closure;
    mx_dielectric_bsdf(1.000000, transmission_color, specular_IOR, transmission_roughness_out, 0.000000, 1.500000, normal1, main_tangent_out, "ggx", "T", transmission_bsdf_out);
    BSDF sheen_bsdf_out = sheen1 * sheen_bsdf(normal1, sheen_color, sheen_roughness);
    float translucent_bsdf_weight_tmp = 1.000000;
    BSDF translucent_bsdf_out = translucent_bsdf_weight_tmp * translucent_bsdf(normal1, coat_affected_subsurface_color_out);
    BSDF subsurface_bsdf_out = null_closure;
    mx_subsurface_bsdf(1.000000, coat_affected_subsurface_color_out, subsurface_radius_scaled_out, subsurface_anisotropy, normal1, subsurface_bsdf_out);
    BSDF selected_subsurface_bsdf_out = mix(subsurface_bsdf_out, translucent_bsdf_out, subsurface_selector_out);
    BSDF diffuse_bsdf_out = base * oren_nayar_diffuse_bsdf(normal1, coat_affected_diffuse_color_out, diffuse_roughness);
    BSDF subsurface_mix_out = mix(diffuse_bsdf_out, selected_subsurface_bsdf_out, subsurface1);
    BSDF sheen_layer_out = layer(sheen_bsdf_out, subsurface_mix_out);
    BSDF transmission_mix_out = mix(sheen_layer_out, transmission_bsdf_out, transmission);
    BSDF specular_layer_out = layer(specular_bsdf_out, transmission_mix_out);
    BSDF metalness_mix_out = mix(specular_layer_out, metal_bsdf_out, metalness);
    BSDF thin_film_layer_attenuated_out = (coat_attenuation_out * metalness_mix_out);
    BSDF coat_layer_out = layer(coat_bsdf_out, thin_film_layer_attenuated_out);
    EDF emission_edf_out = uniform_edf(emission_weight_out);
    EDF coat_tinted_emission_edf_out = (coat_color * emission_edf_out);
    EDF coat_emission_edf_out = null_closure;
    mx_generalized_schlick_edf(emission_color0_out, color(0.000000, 0.000000, 0.000000), 5.000000, coat_tinted_emission_edf_out, coat_emission_edf_out);
    EDF blended_coat_emission_edf_out = mix(emission_edf_out, coat_emission_edf_out, coat);
    surfaceshader shader_constructor_out = surfaceshader(null_closure, null_closure, 1.0);
    mx_surface(coat_layer_out, blended_coat_emission_edf_out, opacity_luminance_float_out, 0, shader_constructor_out);
    out = shader_constructor_out;
}

MATERIAL mx_surfacematerial(surfaceshader surface, surfaceshader backsurface, displacementshader disp)
{
    float opacity_weight = clamp(surface.opacity, 0.0, 1.0);
    return (surface.bsdf + surface.edf) * opacity_weight + transparent() * (1.0 - opacity_weight);
}

shader M_BrickPattern
[[
    string mtlx_category = "surfacematerial",
    string mtlx_name = "M_BrickPattern"
]]
(
    surfaceshader backsurfaceshader = { 0, 0, 1.0 },
    displacementshader displacementshader1 = vector(0.0),
    int geomprop_UV0_index = 0
    [[
        string widget = "number"
    ]],
    float node_convert_1_in = 3.000000
    [[
        string widget = "number"
    ]],
    color node_rgbtohsv_12_in = color(0.661876, 0.190880, 0.000000),
    string geomprop_Nworld_space = "world",
    string geomprop_Tworld_space = "world",
    int geomprop_Tworld_index = 0
    [[
        string widget = "number"
    ]],
    string geomprop_Bworld_space = "world",
    int geomprop_Bworld_index = 0
    [[
        string widget = "number"
    ]],
    string node_tiledimage_float_26_file = "../../../Images/brick_variation_mask.jpg"
    [[
        string widget = "filename"
    ]],
    string node_tiledimage_float_26_file_colorspace = ""
    [[
        string widget = "colorspace"
    ]],
    float node_tiledimage_float_26_default = 0.000000
    [[
        string widget = "number"
    ]],
    vector2 node_tiledimage_float_26_uvoffset = {0.000000, 0.000000},
    vector2 node_tiledimage_float_26_realworldimagesize = {1.000000, 1.000000},
    vector2 node_tiledimage_float_26_realworldtilesize = {1.000000, 1.000000},
    string node_tiledimage_float_26_filtertype = "linear",
    string node_tiledimage_float_26_framerange = "",
    int node_tiledimage_float_26_frameoffset = 0
    [[
        string widget = "number"
    ]],
    string node_tiledimage_float_26_frameendaction = "constant",
    string node_tiledimage_float_7_file = "../../../Images/brick_base_gray.jpg"
    [[
        string widget = "filename"
    ]],
    string node_tiledimage_float_7_file_colorspace = ""
    [[
        string widget = "colorspace"
    ]],
    float node_tiledimage_float_7_default = 0.000000
    [[
        string widget = "number"
    ]],
    vector2 node_tiledimage_float_7_uvoffset = {0.000000, 0.000000},
    vector2 node_tiledimage_float_7_realworldimagesize = {1.000000, 1.000000},
    vector2 node_tiledimage_float_7_realworldtilesize = {1.000000, 1.000000},
    string node_tiledimage_float_7_filtertype = "linear",
    string node_tiledimage_float_7_framerange = "",
    int node_tiledimage_float_7_frameoffset = 0
    [[
        string widget = "number"
    ]],
    string node_tiledimage_float_7_frameendaction = "constant",
    string node_tiledimage_float_24_file = "../../../Images/brick_dirt_mask.jpg"
    [[
        string widget = "filename"
    ]],
    string node_tiledimage_float_24_file_colorspace = ""
    [[
        string widget = "colorspace"
    ]],
    float node_tiledimage_float_24_default = 0.000000
    [[
        string widget = "number"
    ]],
    vector2 node_tiledimage_float_24_uvoffset = {0.000000, 0.000000},
    vector2 node_tiledimage_float_24_realworldimagesize = {1.000000, 1.000000},
    vector2 node_tiledimage_float_24_realworldtilesize = {1.000000, 1.000000},
    string node_tiledimage_float_24_filtertype = "linear",
    string node_tiledimage_float_24_framerange = "",
    int node_tiledimage_float_24_frameoffset = 0
    [[
        string widget = "number"
    ]],
    string node_tiledimage_float_24_frameendaction = "constant",
    string node_tiledimage_float_10_file = "../../../Images/brick_mask.jpg"
    [[
        string widget = "filename"
    ]],
    string node_tiledimage_float_10_file_colorspace = ""
    [[
        string widget = "colorspace"
    ]],
    float node_tiledimage_float_10_default = 0.000000
    [[
        string widget = "number"
    ]],
    vector2 node_tiledimage_float_10_uvoffset = {0.000000, 0.000000},
    vector2 node_tiledimage_float_10_realworldimagesize = {1.000000, 1.000000},
    vector2 node_tiledimage_float_10_realworldtilesize = {1.000000, 1.000000},
    string node_tiledimage_float_10_filtertype = "linear",
    string node_tiledimage_float_10_framerange = "",
    int node_tiledimage_float_10_frameoffset = 0
    [[
        string widget = "number"
    ]],
    string node_tiledimage_float_10_frameendaction = "constant",
    string node_tiledimage_float_22_file = "../../../Images/brick_roughness.jpg"
    [[
        string widget = "filename"
    ]],
    string node_tiledimage_float_22_file_colorspace = ""
    [[
        string widget = "colorspace"
    ]],
    float node_tiledimage_float_22_default = 0.000000
    [[
        string widget = "number"
    ]],
    vector2 node_tiledimage_float_22_uvoffset = {0.000000, 0.000000},
    vector2 node_tiledimage_float_22_realworldimagesize = {1.000000, 1.000000},
    vector2 node_tiledimage_float_22_realworldtilesize = {1.000000, 1.000000},
    string node_tiledimage_float_22_filtertype = "linear",
    string node_tiledimage_float_22_framerange = "",
    int node_tiledimage_float_22_frameoffset = 0
    [[
        string widget = "number"
    ]],
    string node_tiledimage_float_22_frameendaction = "constant",
    string node_tiledimage_vector3_27_file = "../../../Images/brick_normal.jpg"
    [[
        string widget = "filename"
    ]],
    string node_tiledimage_vector3_27_file_colorspace = ""
    [[
        string widget = "colorspace"
    ]],
    vector node_tiledimage_vector3_27_default = vector(0.000000, 0.000000, 0.000000),
    vector2 node_tiledimage_vector3_27_uvoffset = {0.000000, 0.000000},
    vector2 node_tiledimage_vector3_27_realworldimagesize = {1.000000, 1.000000},
    vector2 node_tiledimage_vector3_27_realworldtilesize = {1.000000, 1.000000},
    string node_tiledimage_vector3_27_filtertype = "linear",
    string node_tiledimage_vector3_27_framerange = "",
    int node_tiledimage_vector3_27_frameoffset = 0
    [[
        string widget = "number"
    ]],
    string node_tiledimage_vector3_27_frameendaction = "constant",
    float node_multiply_25_in1 = 0.083000
    [[
        string widget = "number"
    ]],
    float node_multiply_20_in1 = 0.787000
    [[
        string widget = "number"
    ]],
    color node_multiply_9_in1 = color(0.263273, 0.263273, 0.263273),
    float node_multiply_23_in1 = 0.248000
    [[
        string widget = "number"
    ]],
    float node_max_1_in2 = 0.000010
    [[
        string widget = "number"
    ]],
    float node_normalmap_3_scale = 1.000000
    [[
        string widget = "number"
    ]],
    float node_divide_21_in1 = 0.853000
    [[
        string widget = "number"
    ]],
    float node_subtract_18_in2 = 0.350000
    [[
        string widget = "number"
    ]],
    float node_multiply_14_in2 = 0.083000
    [[
        string widget = "number"
    ]],
    float node_combine3_color3_13_in2 = 0.000000
    [[
        string widget = "number"
    ]],
    color node_mix_6_fg = color(0.563720, 0.563720, 0.563720),
    color node_clamp_0_low = color(0.000000, 0.000000, 0.000000),
    color node_clamp_0_high = color(1.000000, 1.000000, 1.000000),
    float N_StandardSurface_base = 1.000000
    [[
        string widget = "number"
    ]],
    float N_StandardSurface_diffuse_roughness = 0.000000
    [[
        string widget = "number"
    ]],
    float N_StandardSurface_metalness = 0.000000
    [[
        string widget = "number"
    ]],
    float N_StandardSurface_specular = 1.000000
    [[
        string widget = "number"
    ]],
    color N_StandardSurface_specular_color = color(1.000000, 1.000000, 1.000000),
    float N_StandardSurface_specular_IOR = 1.500000
    [[
        string widget = "number"
    ]],
    float N_StandardSurface_specular_anisotropy = 0.000000
    [[
        string widget = "number"
    ]],
    float N_StandardSurface_specular_rotation = 0.000000
    [[
        string widget = "number"
    ]],
    float N_StandardSurface_transmission = 0.000000
    [[
        string widget = "number"
    ]],
    color N_StandardSurface_transmission_color = color(1.000000, 1.000000, 1.000000),
    float N_StandardSurface_transmission_depth = 0.000000
    [[
        string widget = "number"
    ]],
    color N_StandardSurface_transmission_scatter = color(0.000000, 0.000000, 0.000000),
    float N_StandardSurface_transmission_scatter_anisotropy = 0.000000
    [[
        string widget = "number"
    ]],
    float N_StandardSurface_transmission_dispersion = 0.000000
    [[
        string widget = "number"
    ]],
    float N_StandardSurface_transmission_extra_roughness = 0.000000
    [[
        string widget = "number"
    ]],
    float N_StandardSurface_subsurface = 0.000000
    [[
        string widget = "number"
    ]],
    color N_StandardSurface_subsurface_color = color(1.000000, 1.000000, 1.000000),
    color N_StandardSurface_subsurface_radius = color(1.000000, 1.000000, 1.000000),
    float N_StandardSurface_subsurface_scale = 1.000000
    [[
        string widget = "number"
    ]],
    float N_StandardSurface_subsurface_anisotropy = 0.000000
    [[
        string widget = "number"
    ]],
    float N_StandardSurface_sheen = 0.000000
    [[
        string widget = "number"
    ]],
    color N_StandardSurface_sheen_color = color(1.000000, 1.000000, 1.000000),
    float N_StandardSurface_sheen_roughness = 0.300000
    [[
        string widget = "number"
    ]],
    float N_StandardSurface_coat = 0.000000
    [[
        string widget = "number"
    ]],
    color N_StandardSurface_coat_color = color(1.000000, 1.000000, 1.000000),
    float N_StandardSurface_coat_roughness = 0.100000
    [[
        string widget = "number"
    ]],
    float N_StandardSurface_coat_anisotropy = 0.000000
    [[
        string widget = "number"
    ]],
    float N_StandardSurface_coat_rotation = 0.000000
    [[
        string widget = "number"
    ]],
    float N_StandardSurface_coat_IOR = 1.500000
    [[
        string widget = "number"
    ]],
    float N_StandardSurface_coat_affect_color = 0.000000
    [[
        string widget = "number"
    ]],
    float N_StandardSurface_coat_affect_roughness = 0.000000
    [[
        string widget = "number"
    ]],
    float N_StandardSurface_thin_film_thickness = 0.000000
    [[
        string widget = "number"
    ]],
    float N_StandardSurface_thin_film_IOR = 1.500000
    [[
        string widget = "number"
    ]],
    float N_StandardSurface_emission = 0.000000
    [[
        string widget = "number"
    ]],
    color N_StandardSurface_emission_color = color(1.000000, 1.000000, 1.000000),
    color N_StandardSurface_opacity = color(1.000000, 1.000000, 1.000000),
    int N_StandardSurface_thin_walled = 0
    [[
        string widget = "checkBox"
    ]],
    output MATERIAL out = 0
)
{
    closure color null_closure = 0;
    textureresource node_tiledimage_float_26_file_ = {node_tiledimage_float_26_file, node_tiledimage_float_26_file_colorspace};
    textureresource node_tiledimage_float_7_file_ = {node_tiledimage_float_7_file, node_tiledimage_float_7_file_colorspace};
    textureresource node_tiledimage_float_24_file_ = {node_tiledimage_float_24_file, node_tiledimage_float_24_file_colorspace};
    textureresource node_tiledimage_float_10_file_ = {node_tiledimage_float_10_file, node_tiledimage_float_10_file_colorspace};
    textureresource node_tiledimage_float_22_file_ = {node_tiledimage_float_22_file, node_tiledimage_float_22_file_colorspace};
    textureresource node_tiledimage_vector3_27_file_ = {node_tiledimage_vector3_27_file, node_tiledimage_vector3_27_file_colorspace};
    vector2 geomprop_UV0_out1 = vector2(u,v);
    vector2 node_convert_1_out = vector2(0.0, 0.0);
    NG_convert_float_vector2(node_convert_1_in, node_convert_1_out);
    color node_rgbtohsv_12_out = color(0.0);
    mx_rgbtohsv_color3(node_rgbtohsv_12_in, node_rgbtohsv_12_out);
    vector geomprop_Nworld_out1 = transform(geomprop_Nworld_space, N);
    vector geomprop_Tworld_out1 = transform(geomprop_Tworld_space, normalize(dPdu));
    vector geomprop_Bworld_out1 = transform(geomprop_Bworld_space, normalize(dPdv));
    float node_tiledimage_float_26_out = 0.0;
    NG_tiledimage_float(node_tiledimage_float_26_file_, node_tiledimage_float_26_default, geomprop_UV0_out1, node_convert_1_out, node_tiledimage_float_26_uvoffset, node_tiledimage_float_26_realworldimagesize, node_tiledimage_float_26_realworldtilesize, node_tiledimage_float_26_filtertype, node_tiledimage_float_26_framerange, node_tiledimage_float_26_frameoffset, node_tiledimage_float_26_frameendaction, node_tiledimage_float_26_out);
    float node_tiledimage_float_7_out = 0.0;
    NG_tiledimage_float(node_tiledimage_float_7_file_, node_tiledimage_float_7_default, geomprop_UV0_out1, node_convert_1_out, node_tiledimage_float_7_uvoffset, node_tiledimage_float_7_realworldimagesize, node_tiledimage_float_7_realworldtilesize, node_tiledimage_float_7_filtertype, node_tiledimage_float_7_framerange, node_tiledimage_float_7_frameoffset, node_tiledimage_float_7_frameendaction, node_tiledimage_float_7_out);
    float node_tiledimage_float_24_out = 0.0;
    NG_tiledimage_float(node_tiledimage_float_24_file_, node_tiledimage_float_24_default, geomprop_UV0_out1, node_convert_1_out, node_tiledimage_float_24_uvoffset, node_tiledimage_float_24_realworldimagesize, node_tiledimage_float_24_realworldtilesize, node_tiledimage_float_24_filtertype, node_tiledimage_float_24_framerange, node_tiledimage_float_24_frameoffset, node_tiledimage_float_24_frameendaction, node_tiledimage_float_24_out);
    float node_tiledimage_float_10_out = 0.0;
    NG_tiledimage_float(node_tiledimage_float_10_file_, node_tiledimage_float_10_default, geomprop_UV0_out1, node_convert_1_out, node_tiledimage_float_10_uvoffset, node_tiledimage_float_10_realworldimagesize, node_tiledimage_float_10_realworldtilesize, node_tiledimage_float_10_filtertype, node_tiledimage_float_10_framerange, node_tiledimage_float_10_frameoffset, node_tiledimage_float_10_frameendaction, node_tiledimage_float_10_out);
    float node_tiledimage_float_22_out = 0.0;
    NG_tiledimage_float(node_tiledimage_float_22_file_, node_tiledimage_float_22_default, geomprop_UV0_out1, node_convert_1_out, node_tiledimage_float_22_uvoffset, node_tiledimage_float_22_realworldimagesize, node_tiledimage_float_22_realworldtilesize, node_tiledimage_float_22_filtertype, node_tiledimage_float_22_framerange, node_tiledimage_float_22_frameoffset, node_tiledimage_float_22_frameendaction, node_tiledimage_float_22_out);
    vector node_tiledimage_vector3_27_out = vector(0.0);
    NG_tiledimage_vector3(node_tiledimage_vector3_27_file_, node_tiledimage_vector3_27_default, geomprop_UV0_out1, node_convert_1_out, node_tiledimage_vector3_27_uvoffset, node_tiledimage_vector3_27_realworldimagesize, node_tiledimage_vector3_27_realworldtilesize, node_tiledimage_vector3_27_filtertype, node_tiledimage_vector3_27_framerange, node_tiledimage_vector3_27_frameoffset, node_tiledimage_vector3_27_frameendaction, node_tiledimage_vector3_27_out);
    float node_multiply_25_out = node_multiply_25_in1 * node_tiledimage_float_26_out;
    float node_multiply_20_out = node_multiply_20_in1 * node_tiledimage_float_26_out;
    color node_multiply_9_out = node_multiply_9_in1 * node_tiledimage_float_7_out;
    float node_multiply_23_out = node_multiply_23_in1 * node_tiledimage_float_24_out;
    float node_max_1_out = max(node_tiledimage_float_10_out, node_max_1_in2);
    vector node_normalmap_3_out = vector(0.0);
    mx_normalmap_float(node_tiledimage_vector3_27_out, node_normalmap_3_scale, geomprop_Nworld_out1, geomprop_Tworld_out1, geomprop_Bworld_out1, node_normalmap_3_out);
    float node_add_19_out = node_multiply_25_out + node_tiledimage_float_7_out;
    float node_divide_21_out = node_divide_21_in1 / node_max_1_out;
    float node_subtract_18_out = node_add_19_out - node_subtract_18_in2;
    float node_multiply_15_out = node_add_19_out * node_multiply_20_out;
    float node_multiply_1_out = node_divide_21_out * node_tiledimage_float_22_out;
    float node_multiply_14_out = node_subtract_18_out * node_multiply_14_in2;
    color node_combine3_color3_13_out = color( node_multiply_14_out,node_combine3_color3_13_in2,node_multiply_15_out );
    color node_add_16_out = node_combine3_color3_13_out + node_rgbtohsv_12_out;
    color node_hsvtorgb_17_out = color(0.0);
    mx_hsvtorgb_color3(node_add_16_out, node_hsvtorgb_17_out);
    color node_mix_6_out = mix(node_hsvtorgb_17_out, node_mix_6_fg, node_multiply_23_out);
    color node_multiply_5_out = node_mix_6_out * node_tiledimage_float_7_out;
    color node_mix_8_out = mix(node_multiply_9_out, node_multiply_5_out, node_tiledimage_float_10_out);
    color node_clamp_0_out = clamp(node_mix_8_out, node_clamp_0_low, node_clamp_0_high);
    surfaceshader N_StandardSurface_out = surfaceshader(null_closure, null_closure, 1.0);
    NG_standard_surface_surfaceshader_100(N_StandardSurface_base, node_clamp_0_out, N_StandardSurface_diffuse_roughness, N_StandardSurface_metalness, N_StandardSurface_specular, N_StandardSurface_specular_color, node_multiply_1_out, N_StandardSurface_specular_IOR, N_StandardSurface_specular_anisotropy, N_StandardSurface_specular_rotation, N_StandardSurface_transmission, N_StandardSurface_transmission_color, N_StandardSurface_transmission_depth, N_StandardSurface_transmission_scatter, N_StandardSurface_transmission_scatter_anisotropy, N_StandardSurface_transmission_dispersion, N_StandardSurface_transmission_extra_roughness, N_StandardSurface_subsurface, N_StandardSurface_subsurface_color, N_StandardSurface_subsurface_radius, N_StandardSurface_subsurface_scale, N_StandardSurface_subsurface_anisotropy, N_StandardSurface_sheen, N_StandardSurface_sheen_color, N_StandardSurface_sheen_roughness, N_StandardSurface_coat, N_StandardSurface_coat_color, N_StandardSurface_coat_roughness, N_StandardSurface_coat_anisotropy, N_StandardSurface_coat_rotation, N_StandardSurface_coat_IOR, geomprop_Nworld_out1, N_StandardSurface_coat_affect_color, N_StandardSurface_coat_affect_roughness, N_StandardSurface_thin_film_thickness, N_StandardSurface_thin_film_IOR, N_StandardSurface_emission, N_StandardSurface_emission_color, N_StandardSurface_opacity, N_StandardSurface_thin_walled, node_normalmap_3_out, geomprop_Tworld_out1, N_StandardSurface_out);
    MATERIAL M_BrickPattern_out = mx_surfacematerial(N_StandardSurface_out, backsurfaceshader, displacementshader1);
    out = M_BrickPattern_out;
}

