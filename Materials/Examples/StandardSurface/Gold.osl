#include "mx_funcs.h"

#define true 1
#define false 0
struct textureresource { string filename; string colorspace; };
#define BSDF closure color
#define EDF closure color
#define VDF closure color
struct surfaceshader { closure color bsdf; closure color edf; float opacity; };
#define volumeshader closure color
#define displacementshader vector
#define lightshader closure color
#define MATERIAL closure color

#define M_FLOAT_EPS 1e-8

void mx_roughness_anisotropy(float roughness, float anisotropy, output vector2 result)
{
    float roughness_sqr = clamp(roughness*roughness, M_FLOAT_EPS, 1.0);
    if (anisotropy > 0.0)
    {
        float aspect = sqrt(1.0 - clamp(anisotropy, 0.0, 0.98));
        result.x = min(roughness_sqr / aspect, 1.0);
        result.y = roughness_sqr * aspect;
    }
    else
    {
        result.x = roughness_sqr;
        result.y = roughness_sqr;
    }
}

void mx_luminance_color3(color in, color lumacoeffs, output color result)
{
    result = dot(in, lumacoeffs);
}

matrix rotationMatrix(vector axis, float angle)
{
    vector nAxis = normalize(axis);
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1.0 - c;

    return matrix(oc * nAxis[0] * nAxis[0] + c,             oc * nAxis[0] * nAxis[1] - nAxis[2] * s,  oc * nAxis[2] * nAxis[0] + nAxis[1] * s,  0.0,
                  oc * nAxis[0] * nAxis[1] + nAxis[2] * s,  oc * nAxis[1] * nAxis[1] + c,             oc * nAxis[1] * nAxis[2] - nAxis[0] * s,  0.0,
                  oc * nAxis[2] * nAxis[0] - nAxis[1] * s,  oc * nAxis[1] * nAxis[2] + nAxis[0] * s,  oc * nAxis[2] * nAxis[2] + c,             0.0,
                  0.0,                                      0.0,                                      0.0,                                      1.0);
}

void mx_rotate_vector3(vector _in, float amount, vector axis, output vector result)
{
    float rotationRadians = radians(amount);
    matrix m = rotationMatrix(axis, rotationRadians);
    vector4 trans = transform(m, vector4(_in[0], _in[1], _in[2], 1.0));
    result = vector(trans.x, trans.y, trans.z);
}

void mx_artistic_ior(color reflectivity, color edge_color, output vector ior, output vector extinction)
{
    // "Artist Friendly Metallic Fresnel", Ole Gulbrandsen, 2014
    // http://jcgt.org/published/0003/04/03/paper.pdf

    color r = clamp(reflectivity, 0.0, 0.99);
    color r_sqrt = sqrt(r);
    color n_min = (1.0 - r) / (1.0 + r);
    color n_max = (1.0 + r_sqrt) / (1.0 - r_sqrt);
    ior = mix(n_max, n_min, edge_color);

    color np1 = ior + 1.0;
    color nm1 = ior - 1.0;
    color k2 = (np1*np1 * r - nm1*nm1) / (1.0 - r);
    k2 = max(k2, 0.0);
    extinction = sqrt(k2);
}

void mx_dielectric_bsdf(float weight, color tint, float ior, vector2 roughness, float thinfilm_thickness, float thinfilm_ior, normal N, vector U, string distribution, string scatter_mode, output BSDF bsdf)
{
    if (scatter_mode == "R")
    {
        bsdf = weight * dielectric_bsdf(N, U, tint, color(0.0), roughness.x, roughness.y, ior, distribution, "thinfilm_thickness", thinfilm_thickness, "thinfilm_ior", thinfilm_ior);
    }
    else if (scatter_mode == "T")
    {
        bsdf = weight * dielectric_bsdf(N, U, color(0.0), tint, roughness.x, roughness.y, ior, distribution, "thinfilm_thickness", thinfilm_thickness, "thinfilm_ior", thinfilm_ior);
    }
    else
    {
        bsdf = weight * dielectric_bsdf(N, U, tint, tint, roughness.x, roughness.y, ior, distribution, "thinfilm_thickness", thinfilm_thickness, "thinfilm_ior", thinfilm_ior);
    }
}

void mx_subsurface_bsdf(float weight, color _color, color radius, float anisotropy, normal N, output BSDF bsdf)
{
    // TODO: Subsurface closure is not supported by vanilla OSL.
    bsdf = _color * weight * diffuse(N);
}

void NG_convert_float_color3(float in, output color out)
{
    color combine_out = color( in,in,in );
    out = combine_out;
}

float mx_square(float x)
{
    return x*x;
}

vector2 mx_square(vector2 x)
{
    return x*x;
}

vector mx_square(vector x)
{
    return x*x;
}

vector4 mx_square(vector4 x)
{
    return x*x;
}

float mx_pow5(float x)
{
    return mx_square(mx_square(x)) * x;
}

color mx_fresnel_conductor(float cosTheta, vector n, vector k)
{
   float c2 = cosTheta*cosTheta;
   vector n2_k2 = n*n + k*k;
   vector nc2 = 2.0 * n * cosTheta;

   vector rs_a = n2_k2 + c2;
   vector rp_a = n2_k2 * c2 + 1.0;
   vector rs = (rs_a - nc2) / (rs_a + nc2);
   vector rp = (rp_a - nc2) / (rp_a + nc2);

   return 0.5 * (rs + rp);
}

// Standard Schlick Fresnel
float mx_fresnel_schlick(float cosTheta, float F0)
{
    float x = clamp(1.0 - cosTheta, 0.0, 1.0);
    float x5 = mx_pow5(x);
    return F0 + (1.0 - F0) * x5;
}
color mx_fresnel_schlick(float cosTheta, color F0)
{
    float x = clamp(1.0 - cosTheta, 0.0, 1.0);
    float x5 = mx_pow5(x);
    return F0 + (1.0 - F0) * x5;
}

// Generalized Schlick Fresnel
float mx_fresnel_schlick(float cosTheta, float F0, float F90)
{
    float x = clamp(1.0 - cosTheta, 0.0, 1.0);
    float x5 = mx_pow5(x);
    return mix(F0, F90, x5);
}
color mx_fresnel_schlick(float cosTheta, color F0, color F90)
{
    float x = clamp(1.0 - cosTheta, 0.0, 1.0);
    float x5 = mx_pow5(x);
    return mix(F0, F90, x5);
}

// Generalized Schlick Fresnel with a variable exponent
color mx_fresnel_schlick(float cosTheta, float f0, float f90, float exponent)
{
    float x = clamp(1.0 - cosTheta, 0.0, 1.0);
    return mix(f0, f90, pow(x, exponent));
}
color mx_fresnel_schlick(float cosTheta, color f0, color f90, float exponent)
{
    float x = clamp(1.0 - cosTheta, 0.0, 1.0);
    return mix(f0, f90, pow(x, exponent));
}

void mx_generalized_schlick_edf(color color0, color color90, float exponent, EDF base, output EDF result)
{
    float NdotV = fabs(dot(N,-I));
    color f = mx_fresnel_schlick(NdotV, color0, color90, exponent);
    result = base * f;
}

void mx_surface(BSDF bsdf, EDF edf, float opacity, int thin_walled, output surfaceshader result)
{
    result.bsdf    = bsdf;
    result.edf     = edf;
    result.opacity = clamp(opacity, 0.0, 1.0);
}

void NG_standard_surface_surfaceshader_100(float base, color base_color, float diffuse_roughness, float metalness, float specular, color specular_color, float specular_roughness, float specular_IOR, float specular_anisotropy, float specular_rotation, float transmission, color transmission_color, float transmission_depth, color transmission_scatter, float transmission_scatter_anisotropy, float transmission_dispersion, float transmission_extra_roughness, float subsurface1, color subsurface_color, color subsurface_radius, float subsurface_scale, float subsurface_anisotropy, float sheen1, color sheen_color, float sheen_roughness, float coat, color coat_color, float coat_roughness, float coat_anisotropy, float coat_rotation, float coat_IOR, vector coat_normal, float coat_affect_color, float coat_affect_roughness, float thin_film_thickness, float thin_film_IOR, float emission1, color emission_color, color opacity, int thin_walled, vector normal1, vector tangent, output surfaceshader out)
{
    closure color null_closure = 0;
    vector2 coat_roughness_vector_out = vector2(0.0, 0.0);
    mx_roughness_anisotropy(coat_roughness, coat_anisotropy, coat_roughness_vector_out);
    float coat_tangent_rotate_degree_in2_tmp = 360.000000;
    float coat_tangent_rotate_degree_out = coat_rotation * coat_tangent_rotate_degree_in2_tmp;
    color metal_reflectivity_out = base_color * base;
    color metal_edgecolor_out = specular_color * specular;
    float coat_affect_roughness_multiply1_out = coat_affect_roughness * coat;
    float tangent_rotate_degree_in2_tmp = 360.000000;
    float tangent_rotate_degree_out = specular_rotation * tangent_rotate_degree_in2_tmp;
    float transmission_roughness_add_out = specular_roughness + transmission_extra_roughness;
    float subsurface_color_nonnegative_in2_tmp = 0.000000;
    color subsurface_color_nonnegative_out = max(subsurface_color, subsurface_color_nonnegative_in2_tmp);
    float coat_clamped_low_tmp = 0.000000;
    float coat_clamped_high_tmp = 1.000000;
    float coat_clamped_out = clamp(coat, coat_clamped_low_tmp, coat_clamped_high_tmp);
    color subsurface_radius_scaled_out = subsurface_radius * subsurface_scale;
    float subsurface_selector_out = float(thin_walled);
    float base_color_nonnegative_in2_tmp = 0.000000;
    color base_color_nonnegative_out = max(base_color, base_color_nonnegative_in2_tmp);
    color coat_attenuation_bg_tmp = color(1.000000, 1.000000, 1.000000);
    color coat_attenuation_out = mix(coat_attenuation_bg_tmp, coat_color, coat);
    float one_minus_coat_ior_in1_tmp = 1.000000;
    float one_minus_coat_ior_out = one_minus_coat_ior_in1_tmp - coat_IOR;
    float one_plus_coat_ior_in1_tmp = 1.000000;
    float one_plus_coat_ior_out = one_plus_coat_ior_in1_tmp + coat_IOR;
    color emission_weight_out = emission_color * emission1;
    color opacity_luminance_out = color(0.0);
    mx_luminance_color3(opacity, color(0.272229, 0.674082, 0.053689), opacity_luminance_out);
    vector coat_tangent_rotate_out = vector(0.0);
    mx_rotate_vector3(tangent, coat_tangent_rotate_degree_out, coat_normal, coat_tangent_rotate_out);
    color artistic_ior_ior = color(0.0);
    color artistic_ior_extinction = color(0.0);
    mx_artistic_ior(metal_reflectivity_out, metal_edgecolor_out, artistic_ior_ior, artistic_ior_extinction);
    float coat_affect_roughness_multiply2_out = coat_affect_roughness_multiply1_out * coat_roughness;
    vector tangent_rotate_out = vector(0.0);
    mx_rotate_vector3(tangent, tangent_rotate_degree_out, normal1, tangent_rotate_out);
    float transmission_roughness_clamped_low_tmp = 0.000000;
    float transmission_roughness_clamped_high_tmp = 1.000000;
    float transmission_roughness_clamped_out = clamp(transmission_roughness_add_out, transmission_roughness_clamped_low_tmp, transmission_roughness_clamped_high_tmp);
    float coat_gamma_multiply_out = coat_clamped_out * coat_affect_color;
    float coat_ior_to_F0_sqrt_out = one_minus_coat_ior_out / one_plus_coat_ior_out;
    int opacity_luminance_float_index_tmp = 0;
    float opacity_luminance_float_out = mx_extract(opacity_luminance_out, opacity_luminance_float_index_tmp);
    vector coat_tangent_rotate_normalize_out = normalize(coat_tangent_rotate_out);
    float coat_affected_roughness_fg_tmp = 1.000000;
    float coat_affected_roughness_out = mix(specular_roughness, coat_affected_roughness_fg_tmp, coat_affect_roughness_multiply2_out);
    vector tangent_rotate_normalize_out = normalize(tangent_rotate_out);
    float coat_affected_transmission_roughness_fg_tmp = 1.000000;
    float coat_affected_transmission_roughness_out = mix(transmission_roughness_clamped_out, coat_affected_transmission_roughness_fg_tmp, coat_affect_roughness_multiply2_out);
    float coat_gamma_in2_tmp = 1.000000;
    float coat_gamma_out = coat_gamma_multiply_out + coat_gamma_in2_tmp;
    float coat_ior_to_F0_out = coat_ior_to_F0_sqrt_out * coat_ior_to_F0_sqrt_out;
    float coat_tangent_value2_tmp = 0.000000;
    vector coat_tangent_out = mx_ternary(coat_anisotropy > coat_tangent_value2_tmp, coat_tangent_rotate_normalize_out, tangent);
    vector2 main_roughness_out = vector2(0.0, 0.0);
    mx_roughness_anisotropy(coat_affected_roughness_out, specular_anisotropy, main_roughness_out);
    float main_tangent_value2_tmp = 0.000000;
    vector main_tangent_out = mx_ternary(specular_anisotropy > main_tangent_value2_tmp, tangent_rotate_normalize_out, tangent);
    vector2 transmission_roughness_out = vector2(0.0, 0.0);
    mx_roughness_anisotropy(coat_affected_transmission_roughness_out, specular_anisotropy, transmission_roughness_out);
    color coat_affected_subsurface_color_out = pow(subsurface_color_nonnegative_out, coat_gamma_out);
    color coat_affected_diffuse_color_out = pow(base_color_nonnegative_out, coat_gamma_out);
    float one_minus_coat_ior_to_F0_in1_tmp = 1.000000;
    float one_minus_coat_ior_to_F0_out = one_minus_coat_ior_to_F0_in1_tmp - coat_ior_to_F0_out;
    color emission_color0_out = color(0.0);
    NG_convert_float_color3(one_minus_coat_ior_to_F0_out, emission_color0_out);
    BSDF coat_bsdf_out = null_closure;
    mx_dielectric_bsdf(coat, color(1.000000, 1.000000, 1.000000), coat_IOR, coat_roughness_vector_out, 0.000000, 1.500000, coat_normal, coat_tangent_out, "ggx", "R", coat_bsdf_out);
    float metal_bsdf_weight_tmp = 1.000000;
    string metal_bsdf_distribution_tmp = "ggx";
    BSDF metal_bsdf_out = metal_bsdf_weight_tmp * conductor_bsdf(normal1, main_tangent_out, main_roughness_out.x, main_roughness_out.y, artistic_ior_ior, artistic_ior_extinction, metal_bsdf_distribution_tmp, "thinfilm_thickness", thin_film_thickness, "thinfilm_ior", thin_film_IOR);
    BSDF specular_bsdf_out = null_closure;
    mx_dielectric_bsdf(specular, specular_color, specular_IOR, main_roughness_out, thin_film_thickness, thin_film_IOR, normal1, main_tangent_out, "ggx", "R", specular_bsdf_out);
    BSDF transmission_bsdf_out = null_closure;
    mx_dielectric_bsdf(1.000000, transmission_color, specular_IOR, transmission_roughness_out, 0.000000, 1.500000, normal1, main_tangent_out, "ggx", "T", transmission_bsdf_out);
    BSDF sheen_bsdf_out = sheen1 * sheen_bsdf(normal1, sheen_color, sheen_roughness);
    float translucent_bsdf_weight_tmp = 1.000000;
    BSDF translucent_bsdf_out = translucent_bsdf_weight_tmp * translucent_bsdf(normal1, coat_affected_subsurface_color_out);
    BSDF subsurface_bsdf_out = null_closure;
    mx_subsurface_bsdf(1.000000, coat_affected_subsurface_color_out, subsurface_radius_scaled_out, subsurface_anisotropy, normal1, subsurface_bsdf_out);
    BSDF selected_subsurface_bsdf_out = mix(subsurface_bsdf_out, translucent_bsdf_out, subsurface_selector_out);
    BSDF diffuse_bsdf_out = base * oren_nayar_diffuse_bsdf(normal1, coat_affected_diffuse_color_out, diffuse_roughness);
    BSDF subsurface_mix_out = mix(diffuse_bsdf_out, selected_subsurface_bsdf_out, subsurface1);
    BSDF sheen_layer_out = layer(sheen_bsdf_out, subsurface_mix_out);
    BSDF transmission_mix_out = mix(sheen_layer_out, transmission_bsdf_out, transmission);
    BSDF specular_layer_out = layer(specular_bsdf_out, transmission_mix_out);
    BSDF metalness_mix_out = mix(specular_layer_out, metal_bsdf_out, metalness);
    BSDF thin_film_layer_attenuated_out = (coat_attenuation_out * metalness_mix_out);
    BSDF coat_layer_out = layer(coat_bsdf_out, thin_film_layer_attenuated_out);
    EDF emission_edf_out = uniform_edf(emission_weight_out);
    EDF coat_tinted_emission_edf_out = (coat_color * emission_edf_out);
    EDF coat_emission_edf_out = null_closure;
    mx_generalized_schlick_edf(emission_color0_out, color(0.000000, 0.000000, 0.000000), 5.000000, coat_tinted_emission_edf_out, coat_emission_edf_out);
    EDF blended_coat_emission_edf_out = mix(emission_edf_out, coat_emission_edf_out, coat);
    surfaceshader shader_constructor_out = surfaceshader(null_closure, null_closure, 1.0);
    mx_surface(coat_layer_out, blended_coat_emission_edf_out, opacity_luminance_float_out, 0, shader_constructor_out);
    out = shader_constructor_out;
}

MATERIAL mx_surfacematerial(surfaceshader surface, surfaceshader backsurface, displacementshader disp)
{
    float opacity_weight = clamp(surface.opacity, 0.0, 1.0);
    return (surface.bsdf + surface.edf) * opacity_weight + transparent() * (1.0 - opacity_weight);
}

shader Gold
[[
    string mtlx_category = "surfacematerial",
    string mtlx_name = "Gold"
]]
(
    surfaceshader backsurfaceshader = { 0, 0, 1.0 },
    displacementshader displacementshader1 = vector(0.0),
    string geomprop_Nworld_space = "world",
    string geomprop_Tworld_space = "world",
    int geomprop_Tworld_index = 0
    [[
        string widget = "number"
    ]],
    float SR_gold_base = 1.000000
    [[
        string widget = "number"
    ]],
    color SR_gold_base_color = color(0.944000, 0.776000, 0.373000),
    float SR_gold_diffuse_roughness = 0.000000
    [[
        string widget = "number"
    ]],
    float SR_gold_metalness = 1.000000
    [[
        string widget = "number"
    ]],
    float SR_gold_specular = 1.000000
    [[
        string widget = "number"
    ]],
    color SR_gold_specular_color = color(0.998000, 0.981000, 0.751000),
    float SR_gold_specular_roughness = 0.020000
    [[
        string widget = "number"
    ]],
    float SR_gold_specular_IOR = 1.500000
    [[
        string widget = "number"
    ]],
    float SR_gold_specular_anisotropy = 0.000000
    [[
        string widget = "number"
    ]],
    float SR_gold_specular_rotation = 0.000000
    [[
        string widget = "number"
    ]],
    float SR_gold_transmission = 0.000000
    [[
        string widget = "number"
    ]],
    color SR_gold_transmission_color = color(1.000000, 1.000000, 1.000000),
    float SR_gold_transmission_depth = 0.000000
    [[
        string widget = "number"
    ]],
    color SR_gold_transmission_scatter = color(0.000000, 0.000000, 0.000000),
    float SR_gold_transmission_scatter_anisotropy = 0.000000
    [[
        string widget = "number"
    ]],
    float SR_gold_transmission_dispersion = 0.000000
    [[
        string widget = "number"
    ]],
    float SR_gold_transmission_extra_roughness = 0.000000
    [[
        string widget = "number"
    ]],
    float SR_gold_subsurface = 0.000000
    [[
        string widget = "number"
    ]],
    color SR_gold_subsurface_color = color(1.000000, 1.000000, 1.000000),
    color SR_gold_subsurface_radius = color(1.000000, 1.000000, 1.000000),
    float SR_gold_subsurface_scale = 1.000000
    [[
        string widget = "number"
    ]],
    float SR_gold_subsurface_anisotropy = 0.000000
    [[
        string widget = "number"
    ]],
    float SR_gold_sheen = 0.000000
    [[
        string widget = "number"
    ]],
    color SR_gold_sheen_color = color(1.000000, 1.000000, 1.000000),
    float SR_gold_sheen_roughness = 0.300000
    [[
        string widget = "number"
    ]],
    float SR_gold_coat = 0.000000
    [[
        string widget = "number"
    ]],
    color SR_gold_coat_color = color(1.000000, 1.000000, 1.000000),
    float SR_gold_coat_roughness = 0.100000
    [[
        string widget = "number"
    ]],
    float SR_gold_coat_anisotropy = 0.000000
    [[
        string widget = "number"
    ]],
    float SR_gold_coat_rotation = 0.000000
    [[
        string widget = "number"
    ]],
    float SR_gold_coat_IOR = 1.500000
    [[
        string widget = "number"
    ]],
    float SR_gold_coat_affect_color = 0.000000
    [[
        string widget = "number"
    ]],
    float SR_gold_coat_affect_roughness = 0.000000
    [[
        string widget = "number"
    ]],
    float SR_gold_thin_film_thickness = 0.000000
    [[
        string widget = "number"
    ]],
    float SR_gold_thin_film_IOR = 1.500000
    [[
        string widget = "number"
    ]],
    float SR_gold_emission = 0.000000
    [[
        string widget = "number"
    ]],
    color SR_gold_emission_color = color(1.000000, 1.000000, 1.000000),
    color SR_gold_opacity = color(1.000000, 1.000000, 1.000000),
    int SR_gold_thin_walled = 0
    [[
        string widget = "checkBox"
    ]],
    output MATERIAL out = 0
)
{
    closure color null_closure = 0;
    vector geomprop_Nworld_out1 = transform(geomprop_Nworld_space, N);
    vector geomprop_Tworld_out1 = transform(geomprop_Tworld_space, normalize(dPdu));
    surfaceshader SR_gold_out = surfaceshader(null_closure, null_closure, 1.0);
    NG_standard_surface_surfaceshader_100(SR_gold_base, SR_gold_base_color, SR_gold_diffuse_roughness, SR_gold_metalness, SR_gold_specular, SR_gold_specular_color, SR_gold_specular_roughness, SR_gold_specular_IOR, SR_gold_specular_anisotropy, SR_gold_specular_rotation, SR_gold_transmission, SR_gold_transmission_color, SR_gold_transmission_depth, SR_gold_transmission_scatter, SR_gold_transmission_scatter_anisotropy, SR_gold_transmission_dispersion, SR_gold_transmission_extra_roughness, SR_gold_subsurface, SR_gold_subsurface_color, SR_gold_subsurface_radius, SR_gold_subsurface_scale, SR_gold_subsurface_anisotropy, SR_gold_sheen, SR_gold_sheen_color, SR_gold_sheen_roughness, SR_gold_coat, SR_gold_coat_color, SR_gold_coat_roughness, SR_gold_coat_anisotropy, SR_gold_coat_rotation, SR_gold_coat_IOR, geomprop_Nworld_out1, SR_gold_coat_affect_color, SR_gold_coat_affect_roughness, SR_gold_thin_film_thickness, SR_gold_thin_film_IOR, SR_gold_emission, SR_gold_emission_color, SR_gold_opacity, SR_gold_thin_walled, geomprop_Nworld_out1, geomprop_Tworld_out1, SR_gold_out);
    MATERIAL Gold_out = mx_surfacematerial(SR_gold_out, backsurfaceshader, displacementshader1);
    out = Gold_out;
}

